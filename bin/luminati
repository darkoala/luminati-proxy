#!/usr/bin/env node
// LICENSE_CODE ZON
'use strict'; /*jslint node:true, esnext:true*/
const _ = require('underscore');
const fs = require('fs');
const path = require('path');
const dns = require('dns');
const express = require('express');
const body_parser = require('body-parser');
const Luminati = require('../lib/luminati.js');
const glob = require('glob');
const net = require('net');
const request = require('request');
const humanize = require('humanize');
const moment = require('moment');
const country_data = require('country-data');
const prompt = require('prompt');
const http = require('http');
const socket_io = require('socket.io');
const socks = require('socksv5');
const hutil = require('hutil');
const util = require('util');
const etask = hutil.etask;
const ef = etask.ef;
const config_file = path.join(process.env.APPDATA||process.env.HOME, '.luminati.json');
const argv = require('yargs').usage('Usage: $0 [options] config1 config2 ...')
.alias({h: 'help'})
.describe({
    p: 'Listening port',
    log: `Log level (${Object.keys(Luminati.log_level).join('|')})`,
    customer: 'Customer',
    password: 'Password',
    proxy: 'Super proxy ip or country',
    proxy_count: 'Number of super proxies to use',
    zone: 'Zone',
    country: 'Country',
    city: 'City',
    asn: 'ASN',
    dns: 'DNS resolving (local|remote)',
    pool_size: 'Pool size',
    ssl: 'Enable SSL sniffing',
    max_requests: 'Requests per session',
    session_timeout: 'Session establish timeout',
    direct_include: 'Include pattern for direct requests',
    direct_exclude: 'Exclude pattern for direct requests',
    www: 'Local web port',
    socks: 'SOCKS5 port (local:remote)',
})
.default({
    p: 23000,
    log: 'WARNING',
    customer: process.env.LUMINATI_CUSTOMER,
    password: process.env.LUMINATI_PASSWORD,
    zone: process.env.LUMINATI_ZONE||'gen',
    max_requests: 50,
    pool_size: 3,
    session_timeout: 5000,
    proxy_count: 1,
    www: 22999,
}).help('h').argv;
let opts = _.pick(argv, 'zone', 'country', 'city', 'asn', 'max_requests',
    'pool_size', 'log', 'session_timeout', 'direct_include', 'direct_exclude',
    'dns');
let config = [];
try {
    config = JSON.parse(fs.readFileSync(config_file, {encoding: 'utf8'}));
} catch(e){ ef(e);
    log('INFO', 'Failed to load config file: '+config_file, e);
}
config = config && config.length && config || [opts];
config.filter(conf=>!conf.port)
    .forEach((conf, i)=>Object.assign(conf, {port: argv.p+i}));

function log(level, msg, extra){
    if (Luminati.log_level[level]>Luminati.log_level[argv.log])
        return;
    let args = [`${level}: ${msg}`];
    if (extra)
        args.push(extra);
    console.log.apply(console, args);
}

const json = opt=>etask(function*(){
    if (typeof opt=='string')
        opt = {url: opt};
    opt.json = true;
    let res = etask.nfn_apply(request, [opt]);
    log('DEBUG', `GET ${opt.url} - ${res.statusCode}`);
    return res;
});

const check_credentials = ()=>etask(function*(){
    prompt.message = 'Luminati credentials';
    prompt.override = argv;
    prompt.start();
    return Object.assign(argv, yield etask.nfn_apply(prompt, '.get', [[{
        name: 'customer',
        description: 'CUSTOMER',
        required: true,
    }, {
        name: 'password',
        description: 'PASSWORD',
        required: true,
    }]]));
});

const resolve_super_proxies = ()=>etask(function*(){
    const hosts = [].concat(argv.proxy||'zproxy.luminati.io')
    .map(host=>etask(function*(){
        if (/^\d+\.\d+\.\d+\.\d+$/.test(host))
        {
            log('DEBUG', `using super proxy ${host}`);
            return host;
        }
        let prefix = '';
        if (host.length==2)
        {
            prefix = `servercountry-${host}-`;
            host = 'zproxy.luminati.io';
        }
        const hosts = {};
        const timestamp = Date.now();
        while (Object.keys(hosts).length<argv.proxy_count &&
            Date.now()-timestamp<30000)
        {
            let domain = `${prefix}session-${Date.now()}.${host}`;
            let ips = yield etask.nfn_apply(dns, '.resolve', [domain]);
            log('DEBUG', `resolving ${domain}`, ips);
            ips.forEach(ip=>hosts[ip] = true);
        }
        return Object.keys(hosts);
    }));
    return [].concat.apply([], yield etask.all(hosts));
});

const create_proxy = (conf, hosts, ssl)=>etask(function*(){
    conf.proxy = conf.proxy || hosts;
    if (conf.direct_include || conf.direct_exclude)
    {
        conf.direct = {};
        if (conf.direct_include)
            conf.direct.include = new RegExp(conf.direct_include, 'i');
        if (conf.direct_exclude)
            conf.direct.exclude = new RegExp(conf.direct_exclude, 'i');
        delete conf.direct_include;
        delete conf.direct_exclude;
    }
    const server = new Luminati(Object.assign(_.pick(argv, 'customer',
        'password'), conf, {ssl: ssl}));
    yield server.listen();
    return server;
});

const create_ssl = ()=>argv.ssl && {
    key: fs.readFileSync('./server.key'),
    cert: fs.readFileSync('./server.crt'),
    ca: fs.readFileSync('./ca.crt'),
    requestCert: true,
    rejectUnauthorized: false,
};

const create_api_interface = ()=>{
    const app = express();
    app.get('/stats', (req, res, next)=>etask(function*(){
        let r = yield json({
            url: 'https://luminati.io/api/get_customer_bw?details=1',
            headers: {'x-hola-auth':
                `lum-customer-${argv.customer}-zone-gen-key-${argv.password}`},
        })
        res.json(r.body[argv.customer]||{});
    }));
    const proxies = {};
    app.post('/create', (req, res, next)=>etask(function*(){
        this.on('ensure', ()=>{
            if (this.error)
                return next(this.error);
        });
        let key = [];
        keys.forEach(field=>{
            if (!req.body[field])
                return;
            key.push(field+'-'+req.body[field]);
        });
        key = key.join('-');
        let server = proxies[key];
        if (server)
        {
            if (server.port)
                return res.json({port: server.port});
            return server.once('ready', ()=>res.json({port: server.port}));
        }
        server = proxies[key] = create_proxy(_.omit(req.body, 'timeout'));
        if (req.body.timeout)
        {
            let timer;
            server.on('idle', idle=>{
                if (timer)
                {
                    clearTimeout(timer);
                    timer = null;
                }
                if (!idle)
                    return;
                timer = setTimeout(()=>etask(function*(){
                    yield server.stop();
                    delete proxies[key];
                }), +req.body.timeout);
            });
        }
        yield server.listen();
        res.json({port: server.port});
    }));
    return app;
};

const create_proxies = hosts=>{
    return etask.all(config.map(conf=>create_proxy(Object.assign(conf,
        {proxy: conf.proxy||hosts, ssl: argv.ssl}))));
};

const add_proxy = (conf, proxies, hosts, ssl)=>etask(function*add_proxy(){
    if (!conf.port||proxies.some(proxy=>proxy.port==conf.port)) {
        conf.port = proxies.reduce((port, proxy)=>{
            if (port<=proxy.port)
                return proxy.port+1;
            return port;
        }, 23000);
    }
    let new_proxy = yield create_proxy(conf, hosts, ssl);
    proxies.push(new_proxy);
    config.push(conf);
    try {
        fs.writeFileSync(config_file, JSON.stringify(config, null, 4), 'utf8');
        log('INFO', 'Config file saved', config_file);
    } catch(e){ ef(e);
        log('WARNING', 'Failed to save the config file: '+config_file, e);
    }
});

const create_web_interface = (proxies, hosts, ssl)=>etask(function*(){
    const timestamp = Date.now();
    const app = express();
    const server = http.Server(app);
    const io = socket_io(server);
    const countries = country_data.countries.all.map(country=>{
        return {code: country.alpha2.toLowerCase(), name: country.name}; })
    .filter(country=>country.code && country.name)
    .sort((c1, c2)=>c1.name.localeCompare(c2.name));
    app.use(body_parser.json());
    app.set('view engine', 'ejs');
    app.set('views', path.join(__dirname, 'views'));
    Object.assign(app.locals, {humanize: humanize, moment: moment});
    app.use(body_parser.urlencoded({extended: true}));
    app.use(body_parser.json());
    app.use('/api', create_api_interface());
    app.use((req, res, next)=>{
        res.locals.path = req.path;
        next();
    });
    app.get('/', (req, res)=>{
        for(let proxy of proxies)
	{
	    let display_opt = _.pick(proxy.opt, ['proxy', 'proxy_count',
	        'zone', 'country', 'city', 'asn', 'dns', 'ssl',
		'max_requests', 'session_timeout', 'direct_include',
		'direct_exclude']);
	    if (display_opt.password)
	        display_opt.password='set';
	    if (display_opt.proxy) {
	        if (display_opt.proxy.length > 1)
	            display_opt.proxy = '['+display_opt.proxy.join(', ')+']';
		else
		    display_opt.proxy = display.opt.proxy[0];
	    }
	    if (display_opt.ssl)
	        display_opt.ssl = true;
	    display_opt = _.pairs(display_opt).filter(pair=>pair[1])
	        .map(pair=>pair.join(':'));
	    proxy.display_opt = display_opt.join(', ');
	}
        res.render('index', {
            proxies: proxies,
            elapsed: Date.now()-timestamp,
            countries: countries,
        });
    });
    app.get('/stats', (req, res, next)=>etask(function*(){
        let r = yield json({
            url: 'https://luminati.io/api/get_customer_bw?details=1',
            headers: {'x-hola-auth':
                `lum-customer-${argv.customer}-zone-gen-key-${argv.password}`},
        })
        res.render('stats', {stats: r.body[argv.customer]||{}});
    }));
    app.post('/add_proxy', (req, res)=>etask(function*add_proxy_route(){
        let conf = _.pick(req.body, ['port', 'password', 'proxy',
	    'proxy_count', 'zone', 'country', 'city', 'asn', 'dns', 'ssl',
	    'max_requests', 'session_timeout', 'direct_include',
	    'direct_exclude']);
	for(let prop of Object.keys(conf))
	{
            if (!conf[prop])
	        delete conf[prop];
	}
        yield add_proxy(conf, proxies, hosts, ssl);
        res.json('OK');
    }));
    app.use(express.static(path.join(__dirname, 'public')));
    app.use((err, req, res, next)=>{
        log('ERROR', err.stack);
        res.status(500).send('Server Error');
    });
    io.on('connection', socket=>etask(function*(){
        const notify = (name, value)=>{
            const data = {};
            data[name] = value;
            io.emit('health', data);
        };
        try {
            yield json('http://lumtest.com/myip');
            notify('network', true);
        } catch(e){ ef(e); notify('network', false); }
        try {
            yield json('http://zproxy.luminati.io:22225/');
            notify('firewall', true);
        } catch(e){ ef(e); notify('firewall', false); }
        try {
            let res = yield json({
                url: 'http://zproxy.luminati.io:22225/',
                headers: {'x-hola-auth':
                    `lum-customer-${argv.customer}-zone-gen-key-${argv.password}`},
            });
            notify('credentials', res.statusCode!=407);
        } catch(e){ ef(e); notify('credentials', false); }
    }));
    setInterval(()=>{
        const stats = {};
        proxies.forEach(proxy=>stats[proxy.port] = proxy.stats);
        io.emit('stats', stats);
    }, 1000);
    server.on('error', err=>this.ethrow(err));
    yield etask.cb_apply(server, '.listen', [argv.www]);
    return server;
});

const create_socks_server = (local, remote)=>etask(function*(){
    const server = socks.createServer((info, accept, deny)=>etask(function*(){
        if (info.dstPort==80)
        {
            info.dstAddr = '127.0.0.1',
            info.dstPort = remote;
            return accept();
        }
        if (info.dstPort==443)
        {
            const socket = accept(true);
            const dst = net.connect(remote, '127.0.0.1');
            dst.on('connect', ()=>{
                dst.write(util.format('CONNECT %s:%d HTTP/1.1\r\n'+
                    'Host: %s:%d\r\n\r\n', info.dstAddr, info.dstPort,
                    info.dstAddr, info.dstPort));
                socket.pipe(dst);
            });
            return dst.once('data', ()=>{ dst.pipe(socket); });
        }
        accept();
    }));
    server.useAuth(socks.auth.None());
    yield etask.cb_apply(server, '.listen', [local]);
    return server;
});

etask(function*(){
    try {
        yield check_credentials();
        const hosts = yield resolve_super_proxies();
	const ssl = create_ssl();
        const proxies = yield create_proxies(hosts, ssl);
        proxies.forEach(server=>log('DEBUG', 'created local proxy', server.opt));
        if (argv.www)
        {
            const server = yield create_web_interface(proxies, hosts, ssl);
            console.log(`admin interface is available at http://127.0.0.1:${server.address().port}`);
        }
        [].concat(argv.socks||[]).forEach(ports=>etask(function*(){
            ports = ports.split(':');
            const server = yield create_socks_server(+ports[0], +ports[1]);
            console.log(`SOCKS5 is available at 127.0.0.1:${server.address().port}`);
        }));
    } catch(e){ ef(e); console.log(e, e.stack); }
});
